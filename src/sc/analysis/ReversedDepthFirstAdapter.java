/* This file was generated by SableCC (http://www.sablecc.org/). */

package sc.analysis;

import java.util.*;
import sc.node.*;

public class ReversedDepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getEOF().apply(this);
        node.getPRealvalues().apply(this);
        outStart(node);
    }

    public void inAFalseRealvalues(AFalseRealvalues node)
    {
        defaultIn(node);
    }

    public void outAFalseRealvalues(AFalseRealvalues node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFalseRealvalues(AFalseRealvalues node)
    {
        inAFalseRealvalues(node);
        if(node.getFalse() != null)
        {
            node.getFalse().apply(this);
        }
        outAFalseRealvalues(node);
    }

    public void inATrueRealvalues(ATrueRealvalues node)
    {
        defaultIn(node);
    }

    public void outATrueRealvalues(ATrueRealvalues node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATrueRealvalues(ATrueRealvalues node)
    {
        inATrueRealvalues(node);
        if(node.getTrue() != null)
        {
            node.getTrue().apply(this);
        }
        outATrueRealvalues(node);
    }

    public void inANombreRealvalues(ANombreRealvalues node)
    {
        defaultIn(node);
    }

    public void outANombreRealvalues(ANombreRealvalues node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANombreRealvalues(ANombreRealvalues node)
    {
        inANombreRealvalues(node);
        if(node.getNombre() != null)
        {
            node.getNombre().apply(this);
        }
        outANombreRealvalues(node);
    }

    public void inAOrLog(AOrLog node)
    {
        defaultIn(node);
    }

    public void outAOrLog(AOrLog node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOrLog(AOrLog node)
    {
        inAOrLog(node);
        if(node.getOr() != null)
        {
            node.getOr().apply(this);
        }
        outAOrLog(node);
    }

    public void inAAndLog(AAndLog node)
    {
        defaultIn(node);
    }

    public void outAAndLog(AAndLog node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAndLog(AAndLog node)
    {
        inAAndLog(node);
        if(node.getAnd() != null)
        {
            node.getAnd().apply(this);
        }
        outAAndLog(node);
    }

    public void inALogOperations(ALogOperations node)
    {
        defaultIn(node);
    }

    public void outALogOperations(ALogOperations node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALogOperations(ALogOperations node)
    {
        inALogOperations(node);
        if(node.getLog() != null)
        {
            node.getLog().apply(this);
        }
        outALogOperations(node);
    }

    public void inACmpOperations(ACmpOperations node)
    {
        defaultIn(node);
    }

    public void outACmpOperations(ACmpOperations node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACmpOperations(ACmpOperations node)
    {
        inACmpOperations(node);
        if(node.getCmp() != null)
        {
            node.getCmp().apply(this);
        }
        outACmpOperations(node);
    }

    public void inAIdentifSinglevalue(AIdentifSinglevalue node)
    {
        defaultIn(node);
    }

    public void outAIdentifSinglevalue(AIdentifSinglevalue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIdentifSinglevalue(AIdentifSinglevalue node)
    {
        inAIdentifSinglevalue(node);
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        outAIdentifSinglevalue(node);
    }

    public void inANotidentifSinglevalue(ANotidentifSinglevalue node)
    {
        defaultIn(node);
    }

    public void outANotidentifSinglevalue(ANotidentifSinglevalue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANotidentifSinglevalue(ANotidentifSinglevalue node)
    {
        inANotidentifSinglevalue(node);
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        if(node.getNot() != null)
        {
            node.getNot().apply(this);
        }
        outANotidentifSinglevalue(node);
    }

    public void inABooleansSinglevalue(ABooleansSinglevalue node)
    {
        defaultIn(node);
    }

    public void outABooleansSinglevalue(ABooleansSinglevalue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABooleansSinglevalue(ABooleansSinglevalue node)
    {
        inABooleansSinglevalue(node);
        if(node.getBooleans() != null)
        {
            node.getBooleans().apply(this);
        }
        outABooleansSinglevalue(node);
    }

    public void inANombreSinglevalue(ANombreSinglevalue node)
    {
        defaultIn(node);
    }

    public void outANombreSinglevalue(ANombreSinglevalue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANombreSinglevalue(ANombreSinglevalue node)
    {
        inANombreSinglevalue(node);
        if(node.getNombre() != null)
        {
            node.getNombre().apply(this);
        }
        outANombreSinglevalue(node);
    }

    public void inACallfuncSinglevalue(ACallfuncSinglevalue node)
    {
        defaultIn(node);
    }

    public void outACallfuncSinglevalue(ACallfuncSinglevalue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACallfuncSinglevalue(ACallfuncSinglevalue node)
    {
        inACallfuncSinglevalue(node);
        if(node.getRp() != null)
        {
            node.getRp().apply(this);
        }
        if(node.getNparam() != null)
        {
            node.getNparam().apply(this);
        }
        if(node.getLp() != null)
        {
            node.getLp().apply(this);
        }
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        outACallfuncSinglevalue(node);
    }

    public void inAMultiplevaluesValue(AMultiplevaluesValue node)
    {
        defaultIn(node);
    }

    public void outAMultiplevaluesValue(AMultiplevaluesValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultiplevaluesValue(AMultiplevaluesValue node)
    {
        inAMultiplevaluesValue(node);
        if(node.getValue() != null)
        {
            node.getValue().apply(this);
        }
        if(node.getOperations() != null)
        {
            node.getOperations().apply(this);
        }
        if(node.getSinglevalue() != null)
        {
            node.getSinglevalue().apply(this);
        }
        outAMultiplevaluesValue(node);
    }

    public void inASinglevalueValue(ASinglevalueValue node)
    {
        defaultIn(node);
    }

    public void outASinglevalueValue(ASinglevalueValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASinglevalueValue(ASinglevalueValue node)
    {
        inASinglevalueValue(node);
        if(node.getSinglevalue() != null)
        {
            node.getSinglevalue().apply(this);
        }
        outASinglevalueValue(node);
    }

    public void inABiggerCmp(ABiggerCmp node)
    {
        defaultIn(node);
    }

    public void outABiggerCmp(ABiggerCmp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABiggerCmp(ABiggerCmp node)
    {
        inABiggerCmp(node);
        if(node.getBigger() != null)
        {
            node.getBigger().apply(this);
        }
        outABiggerCmp(node);
    }

    public void inASmallerCmp(ASmallerCmp node)
    {
        defaultIn(node);
    }

    public void outASmallerCmp(ASmallerCmp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASmallerCmp(ASmallerCmp node)
    {
        inASmallerCmp(node);
        if(node.getSmaller() != null)
        {
            node.getSmaller().apply(this);
        }
        outASmallerCmp(node);
    }

    public void inANotequalCmp(ANotequalCmp node)
    {
        defaultIn(node);
    }

    public void outANotequalCmp(ANotequalCmp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANotequalCmp(ANotequalCmp node)
    {
        inANotequalCmp(node);
        if(node.getNotequal() != null)
        {
            node.getNotequal().apply(this);
        }
        outANotequalCmp(node);
    }

    public void inAEqualCmp(AEqualCmp node)
    {
        defaultIn(node);
    }

    public void outAEqualCmp(AEqualCmp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEqualCmp(AEqualCmp node)
    {
        inAEqualCmp(node);
        if(node.getEqual() != null)
        {
            node.getEqual().apply(this);
        }
        outAEqualCmp(node);
    }

    public void inAEntierType(AEntierType node)
    {
        defaultIn(node);
    }

    public void outAEntierType(AEntierType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEntierType(AEntierType node)
    {
        inAEntierType(node);
        if(node.getEntier() != null)
        {
            node.getEntier().apply(this);
        }
        outAEntierType(node);
    }

    public void inABooleanType(ABooleanType node)
    {
        defaultIn(node);
    }

    public void outABooleanType(ABooleanType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABooleanType(ABooleanType node)
    {
        inABooleanType(node);
        if(node.getBoolean() != null)
        {
            node.getBoolean().apply(this);
        }
        outABooleanType(node);
    }

    public void inAPlusOp(APlusOp node)
    {
        defaultIn(node);
    }

    public void outAPlusOp(APlusOp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPlusOp(APlusOp node)
    {
        inAPlusOp(node);
        if(node.getPlus() != null)
        {
            node.getPlus().apply(this);
        }
        outAPlusOp(node);
    }

    public void inAMinusOp(AMinusOp node)
    {
        defaultIn(node);
    }

    public void outAMinusOp(AMinusOp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMinusOp(AMinusOp node)
    {
        inAMinusOp(node);
        if(node.getMinus() != null)
        {
            node.getMinus().apply(this);
        }
        outAMinusOp(node);
    }

    public void inAMultOp(AMultOp node)
    {
        defaultIn(node);
    }

    public void outAMultOp(AMultOp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultOp(AMultOp node)
    {
        inAMultOp(node);
        if(node.getMult() != null)
        {
            node.getMult().apply(this);
        }
        outAMultOp(node);
    }

    public void inADivOp(ADivOp node)
    {
        defaultIn(node);
    }

    public void outADivOp(ADivOp node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADivOp(ADivOp node)
    {
        inADivOp(node);
        if(node.getDiv() != null)
        {
            node.getDiv().apply(this);
        }
        outADivOp(node);
    }

    public void inATrueBooleans(ATrueBooleans node)
    {
        defaultIn(node);
    }

    public void outATrueBooleans(ATrueBooleans node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATrueBooleans(ATrueBooleans node)
    {
        inATrueBooleans(node);
        if(node.getTrue() != null)
        {
            node.getTrue().apply(this);
        }
        outATrueBooleans(node);
    }

    public void inAFalseBooleans(AFalseBooleans node)
    {
        defaultIn(node);
    }

    public void outAFalseBooleans(AFalseBooleans node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFalseBooleans(AFalseBooleans node)
    {
        inAFalseBooleans(node);
        if(node.getFalse() != null)
        {
            node.getFalse().apply(this);
        }
        outAFalseBooleans(node);
    }

    public void inAIdentifNparameters(AIdentifNparameters node)
    {
        defaultIn(node);
    }

    public void outAIdentifNparameters(AIdentifNparameters node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIdentifNparameters(AIdentifNparameters node)
    {
        inAIdentifNparameters(node);
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        outAIdentifNparameters(node);
    }

    public void inANombreNparameters(ANombreNparameters node)
    {
        defaultIn(node);
    }

    public void outANombreNparameters(ANombreNparameters node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANombreNparameters(ANombreNparameters node)
    {
        inANombreNparameters(node);
        if(node.getNombre() != null)
        {
            node.getNombre().apply(this);
        }
        outANombreNparameters(node);
    }

    public void inABooleansNparameters(ABooleansNparameters node)
    {
        defaultIn(node);
    }

    public void outABooleansNparameters(ABooleansNparameters node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABooleansNparameters(ABooleansNparameters node)
    {
        inABooleansNparameters(node);
        if(node.getBooleans() != null)
        {
            node.getBooleans().apply(this);
        }
        outABooleansNparameters(node);
    }

    public void inAMultiparamNparam(AMultiparamNparam node)
    {
        defaultIn(node);
    }

    public void outAMultiparamNparam(AMultiparamNparam node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultiparamNparam(AMultiparamNparam node)
    {
        inAMultiparamNparam(node);
        if(node.getNparam() != null)
        {
            node.getNparam().apply(this);
        }
        if(node.getVirgul() != null)
        {
            node.getVirgul().apply(this);
        }
        if(node.getNparameters() != null)
        {
            node.getNparameters().apply(this);
        }
        outAMultiparamNparam(node);
    }

    public void inASingleparamNparam(ASingleparamNparam node)
    {
        defaultIn(node);
    }

    public void outASingleparamNparam(ASingleparamNparam node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASingleparamNparam(ASingleparamNparam node)
    {
        inASingleparamNparam(node);
        if(node.getNparameters() != null)
        {
            node.getNparameters().apply(this);
        }
        outASingleparamNparam(node);
    }

    public void inAAffectation(AAffectation node)
    {
        defaultIn(node);
    }

    public void outAAffectation(AAffectation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAffectation(AAffectation node)
    {
        inAAffectation(node);
        if(node.getValue() != null)
        {
            node.getValue().apply(this);
        }
        if(node.getEqual() != null)
        {
            node.getEqual().apply(this);
        }
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        outAAffectation(node);
    }

    public void inACondition(ACondition node)
    {
        defaultIn(node);
    }

    public void outACondition(ACondition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACondition(ACondition node)
    {
        inACondition(node);
        if(node.getElsecondition() != null)
        {
            node.getElsecondition().apply(this);
        }
        if(node.getEndfunc() != null)
        {
            node.getEndfunc().apply(this);
        }
        {
            List<PInstruction> copy = new ArrayList<PInstruction>(node.getInstruction());
            Collections.reverse(copy);
            for(PInstruction e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getStartfunc() != null)
        {
            node.getStartfunc().apply(this);
        }
        if(node.getAlors() != null)
        {
            node.getAlors().apply(this);
        }
        if(node.getRp() != null)
        {
            node.getRp().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getLp() != null)
        {
            node.getLp().apply(this);
        }
        if(node.getSi() != null)
        {
            node.getSi().apply(this);
        }
        outACondition(node);
    }

    public void inALoop(ALoop node)
    {
        defaultIn(node);
    }

    public void outALoop(ALoop node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALoop(ALoop node)
    {
        inALoop(node);
        if(node.getEndfunc() != null)
        {
            node.getEndfunc().apply(this);
        }
        {
            List<PInstruction> copy = new ArrayList<PInstruction>(node.getInstruction());
            Collections.reverse(copy);
            for(PInstruction e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getStartfunc() != null)
        {
            node.getStartfunc().apply(this);
        }
        if(node.getDo() != null)
        {
            node.getDo().apply(this);
        }
        if(node.getRp() != null)
        {
            node.getRp().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getLp() != null)
        {
            node.getLp().apply(this);
        }
        if(node.getWhile() != null)
        {
            node.getWhile().apply(this);
        }
        outALoop(node);
    }

    public void inAElsecondition(AElsecondition node)
    {
        defaultIn(node);
    }

    public void outAElsecondition(AElsecondition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAElsecondition(AElsecondition node)
    {
        inAElsecondition(node);
        if(node.getEndfunc() != null)
        {
            node.getEndfunc().apply(this);
        }
        {
            List<PInstruction> copy = new ArrayList<PInstruction>(node.getInstruction());
            Collections.reverse(copy);
            for(PInstruction e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getStartfunc() != null)
        {
            node.getStartfunc().apply(this);
        }
        if(node.getElse() != null)
        {
            node.getElse().apply(this);
        }
        outAElsecondition(node);
    }

    public void inAMultipleExpression(AMultipleExpression node)
    {
        defaultIn(node);
    }

    public void outAMultipleExpression(AMultipleExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultipleExpression(AMultipleExpression node)
    {
        inAMultipleExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getLog() != null)
        {
            node.getLog().apply(this);
        }
        if(node.getSingleexpression() != null)
        {
            node.getSingleexpression().apply(this);
        }
        outAMultipleExpression(node);
    }

    public void inASingleExpression(ASingleExpression node)
    {
        defaultIn(node);
    }

    public void outASingleExpression(ASingleExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASingleExpression(ASingleExpression node)
    {
        inASingleExpression(node);
        if(node.getSingleexpression() != null)
        {
            node.getSingleexpression().apply(this);
        }
        outASingleExpression(node);
    }

    public void inAIdentifidentifSingleexpression(AIdentifidentifSingleexpression node)
    {
        defaultIn(node);
    }

    public void outAIdentifidentifSingleexpression(AIdentifidentifSingleexpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIdentifidentifSingleexpression(AIdentifidentifSingleexpression node)
    {
        inAIdentifidentifSingleexpression(node);
        if(node.getSecond() != null)
        {
            node.getSecond().apply(this);
        }
        if(node.getCmp() != null)
        {
            node.getCmp().apply(this);
        }
        if(node.getFirst() != null)
        {
            node.getFirst().apply(this);
        }
        outAIdentifidentifSingleexpression(node);
    }

    public void inAIdentifrealvalueSingleexpression(AIdentifrealvalueSingleexpression node)
    {
        defaultIn(node);
    }

    public void outAIdentifrealvalueSingleexpression(AIdentifrealvalueSingleexpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIdentifrealvalueSingleexpression(AIdentifrealvalueSingleexpression node)
    {
        inAIdentifrealvalueSingleexpression(node);
        if(node.getRealvalues() != null)
        {
            node.getRealvalues().apply(this);
        }
        if(node.getCmp() != null)
        {
            node.getCmp().apply(this);
        }
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        outAIdentifrealvalueSingleexpression(node);
    }

    public void inARealvalueidentifSingleexpression(ARealvalueidentifSingleexpression node)
    {
        defaultIn(node);
    }

    public void outARealvalueidentifSingleexpression(ARealvalueidentifSingleexpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARealvalueidentifSingleexpression(ARealvalueidentifSingleexpression node)
    {
        inARealvalueidentifSingleexpression(node);
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        if(node.getCmp() != null)
        {
            node.getCmp().apply(this);
        }
        if(node.getRealvalues() != null)
        {
            node.getRealvalues().apply(this);
        }
        outARealvalueidentifSingleexpression(node);
    }

    public void inAParameter(AParameter node)
    {
        defaultIn(node);
    }

    public void outAParameter(AParameter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParameter(AParameter node)
    {
        inAParameter(node);
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        if(node.getType() != null)
        {
            node.getType().apply(this);
        }
        outAParameter(node);
    }

    public void inAMultipleParameters(AMultipleParameters node)
    {
        defaultIn(node);
    }

    public void outAMultipleParameters(AMultipleParameters node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultipleParameters(AMultipleParameters node)
    {
        inAMultipleParameters(node);
        if(node.getParameters() != null)
        {
            node.getParameters().apply(this);
        }
        if(node.getVirgul() != null)
        {
            node.getVirgul().apply(this);
        }
        if(node.getParameter() != null)
        {
            node.getParameter().apply(this);
        }
        outAMultipleParameters(node);
    }

    public void inASingleParameters(ASingleParameters node)
    {
        defaultIn(node);
    }

    public void outASingleParameters(ASingleParameters node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASingleParameters(ASingleParameters node)
    {
        inASingleParameters(node);
        if(node.getParameter() != null)
        {
            node.getParameter().apply(this);
        }
        outASingleParameters(node);
    }

    public void inADefaultProgramme(ADefaultProgramme node)
    {
        defaultIn(node);
    }

    public void outADefaultProgramme(ADefaultProgramme node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADefaultProgramme(ADefaultProgramme node)
    {
        inADefaultProgramme(node);
        if(node.getProgramme() != null)
        {
            node.getProgramme().apply(this);
        }
        if(node.getFunction() != null)
        {
            node.getFunction().apply(this);
        }
        outADefaultProgramme(node);
    }

    public void inAMainProgramme(AMainProgramme node)
    {
        defaultIn(node);
    }

    public void outAMainProgramme(AMainProgramme node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMainProgramme(AMainProgramme node)
    {
        inAMainProgramme(node);
        if(node.getMain() != null)
        {
            node.getMain().apply(this);
        }
        outAMainProgramme(node);
    }

    public void inAMain(AMain node)
    {
        defaultIn(node);
    }

    public void outAMain(AMain node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMain(AMain node)
    {
        inAMain(node);
        if(node.getEndfunc() != null)
        {
            node.getEndfunc().apply(this);
        }
        {
            List<PInstruction> copy = new ArrayList<PInstruction>(node.getInstruction());
            Collections.reverse(copy);
            for(PInstruction e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getStartfunc() != null)
        {
            node.getStartfunc().apply(this);
        }
        if(node.getParameters() != null)
        {
            node.getParameters().apply(this);
        }
        if(node.getMainfunc() != null)
        {
            node.getMainfunc().apply(this);
        }
        outAMain(node);
    }

    public void inAAffectationInstruction(AAffectationInstruction node)
    {
        defaultIn(node);
    }

    public void outAAffectationInstruction(AAffectationInstruction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAffectationInstruction(AAffectationInstruction node)
    {
        inAAffectationInstruction(node);
        if(node.getAffectation() != null)
        {
            node.getAffectation().apply(this);
        }
        outAAffectationInstruction(node);
    }

    public void inAConditionInstruction(AConditionInstruction node)
    {
        defaultIn(node);
    }

    public void outAConditionInstruction(AConditionInstruction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAConditionInstruction(AConditionInstruction node)
    {
        inAConditionInstruction(node);
        if(node.getCondition() != null)
        {
            node.getCondition().apply(this);
        }
        outAConditionInstruction(node);
    }

    public void inACallfuncInstruction(ACallfuncInstruction node)
    {
        defaultIn(node);
    }

    public void outACallfuncInstruction(ACallfuncInstruction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACallfuncInstruction(ACallfuncInstruction node)
    {
        inACallfuncInstruction(node);
        if(node.getPv() != null)
        {
            node.getPv().apply(this);
        }
        if(node.getRp() != null)
        {
            node.getRp().apply(this);
        }
        if(node.getNparam() != null)
        {
            node.getNparam().apply(this);
        }
        if(node.getLp() != null)
        {
            node.getLp().apply(this);
        }
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        outACallfuncInstruction(node);
    }

    public void inAReadInstruction(AReadInstruction node)
    {
        defaultIn(node);
    }

    public void outAReadInstruction(AReadInstruction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReadInstruction(AReadInstruction node)
    {
        inAReadInstruction(node);
        if(node.getRead() != null)
        {
            node.getRead().apply(this);
        }
        outAReadInstruction(node);
    }

    public void inAWriteInstruction(AWriteInstruction node)
    {
        defaultIn(node);
    }

    public void outAWriteInstruction(AWriteInstruction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAWriteInstruction(AWriteInstruction node)
    {
        inAWriteInstruction(node);
        if(node.getPv() != null)
        {
            node.getPv().apply(this);
        }
        if(node.getRp() != null)
        {
            node.getRp().apply(this);
        }
        if(node.getIdentif() != null)
        {
            node.getIdentif().apply(this);
        }
        if(node.getLp() != null)
        {
            node.getLp().apply(this);
        }
        if(node.getWrite() != null)
        {
            node.getWrite().apply(this);
        }
        outAWriteInstruction(node);
    }

    public void inAFunction(AFunction node)
    {
        defaultIn(node);
    }

    public void outAFunction(AFunction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFunction(AFunction node)
    {
        inAFunction(node);
        if(node.getEndfunc() != null)
        {
            node.getEndfunc().apply(this);
        }
        if(node.getPv() != null)
        {
            node.getPv().apply(this);
        }
        if(node.getSecond() != null)
        {
            node.getSecond().apply(this);
        }
        if(node.getReturn() != null)
        {
            node.getReturn().apply(this);
        }
        {
            List<PInstruction> copy = new ArrayList<PInstruction>(node.getInstruction());
            Collections.reverse(copy);
            for(PInstruction e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getStartfunc() != null)
        {
            node.getStartfunc().apply(this);
        }
        if(node.getDeclaration() != null)
        {
            node.getDeclaration().apply(this);
        }
        if(node.getRp() != null)
        {
            node.getRp().apply(this);
        }
        if(node.getFuncparams() != null)
        {
            node.getFuncparams().apply(this);
        }
        if(node.getLp() != null)
        {
            node.getLp().apply(this);
        }
        if(node.getFirst() != null)
        {
            node.getFirst().apply(this);
        }
        if(node.getType() != null)
        {
            node.getType().apply(this);
        }
        outAFunction(node);
    }
}
