Package sc;

Helpers

lettre = [['a' .. 'z'] + ['A' .. 'Z']];
chiffre = ['0' .. '9'];
alpha = [lettre + ['_' + '$']];
alphanum = [lettre + chiffre];

Tokens

espaces=(' ' | 13 | 10)+;
commentaire= '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);
virgule =',';
nombre =chiffre+;
identif =alpha alphanum*;
plus='+';
minus='-';
mult='*';
div='/';
lp='(';
rp=')';
equal='=';
startfunc='{';
endfunc='}';
virgul=',';
pv=';';
true='true';
false='false';
return='return';
entier='entier';
boolean='bool';
mainfunc='main()';
si='si';
and='&';
or='|';
not='!';
bigger='>';
smaller='<';
notequal='!=';
alors='alors';
else='sinon';
while='tantque';
do='faire';
read='lire();';
write='ecrire';
Ignored Tokens

espaces, commentaire;

Productions

realvalues={false}false|{true}true|{nombre}nombre;
log={or}or|{and}and;
cmp={bigger}bigger |{smaller}smaller | {notequal}notequal | {equal}equal;
type={entier}entier|{boolean} boolean ;
op={plus}plus|{minus}minus|{mult}mult|{div}div;
booleans={true}true|{false}false;
nparameters={identif}identif |{nombre} nombre |{booleans}booleans;
nparam={multiparam} nparameters virgul nparam |{singleparam} nparameters;
var={callfunc} identif lp nparam? rp|{identif}identif |{nombre}nombre;
realvar={multivar} var op realvar |{singlevar} var;
affectation=identif equal realvar;
condition = si lp expression rp alors startfunc instruction* endfunc elsecondition?;
loop=while lp expression rp do startfunc instruction* endfunc;


elsecondition=else startfunc instruction* endfunc;
expression={multiple}singleexpression log expression |{single}singleexpression;
singleexpression={identifidentif}[first]:identif cmp [second]:identif |{identifrealvalue}identif cmp realvalues|{realvalueidentif}realvalues cmp identif;
parameter= type identif;
parameters = {multiple} parameter virgul parameters |{single} parameter;
programme ={default} function programme | {main}main;
main = mainfunc parameters? startfunc instruction* endfunc;
instruction={affectation}affectation|{condition}condition|{callfunc} identif lp nparam? rp pv|{read} read|{write} write lp identif rp pv;
function=type [first]:identif lp [funcparams]:parameters? rp [declaration]:parameters? startfunc instruction* return [second]:identif pv endfunc;
