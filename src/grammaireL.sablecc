Package sc;

Helpers

lettre = [['a' .. 'z'] + ['A' .. 'Z']];
chiffre = ['0' .. '9'];
alpha = [lettre + ['_' + '$']];
alphanum = [lettre + chiffre];

Tokens

espaces = (' ' | 13 | 10)+;
commentaire= '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);
virgule = ',';
nombre = chiffre+;
identif = alpha alphanum*;
plus='+';
minus='-';
mult='*';
div='/';
lp='(';
rp=')';
equal='=';
startfunc='{';
endfunc='}';
virgul=',';
pv=';';
true='true';
false='false';
return='return';
entier='entier';
boolean='bool';
mainfunc='main()';
si='si';
and='&';
or='|';
not='!';
bigger='>';
smaller='<';
notequal='!=';
alors='alors';
else='sinon';
while='tantque';
do='faire';
read='lire();';
write='ecrire';
Ignored Tokens

espaces, commentaire;

Productions

realvalues={false}false|{true}true|{nombre}nombre;

log={or}or|{and}and;

operations ={log} log | {cmp}cmp;

singlevalue={identif} identif |{notidentif} not identif |{booleans} booleans | {nombre} nombre | {callfunc} identif lp nparam? rp;

value= {multiplevalues} singlevalue operations value | {singlevalue} singlevalue;

cmp={bigger}bigger |{smaller}smaller | {notequal}notequal | {equal}equal;

type={entier}entier|{boolean} boolean ;

op={plus}plus|{minus}minus|{mult}mult|{div}div;

booleans={true}true|{false}false;

nparameters={identif}identif |{nombre} nombre |{booleans}booleans;

nparam={multiparam} nparameters virgul nparam |{singleparam} nparameters;

affectation=identif equal value;

condition = si lp expression rp alors startfunc instruction* endfunc elsecondition?;

loop=while lp expression rp do startfunc instruction* endfunc;

elsecondition=else startfunc instruction* endfunc;

expression={multiple}singleexpression log expression |{single}singleexpression;

singleexpression={identifidentif}[first]:identif cmp [second]:identif |{identifrealvalue}identif cmp realvalues|{realvalueidentif}realvalues cmp identif;

parameter= type identif;

parameters = {multiple} parameter virgul parameters |{single} parameter;

programme ={default} function programme | {main}main;


main = mainfunc parameters? startfunc instruction* endfunc;


instruction={affectation}affectation|{condition}condition|{callfunc} identif lp nparam? rp pv|{read} identif equal read|{write} write lp value rp pv ;


function=type identif [firstlp]:lp [funcparams]:parameters? [firstrp]:rp [declaration]:parameters? startfunc instruction* return [secondlp]:lp value [secondrp]:rp pv endfunc;
